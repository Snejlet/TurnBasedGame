Stop the tileHighlights from appearing on collision tiles, and tiles which contain other objects they should not be
    able to pass through (e.g. other actors).
    -poss. loop through mapGrid[] and check value of position in array, and have it not draw if it is position 5.
    -not sure about other actors. Poss. a second for loop within the first, but that seems like it would be really
        inefficient.

Figure out how to get the round number to increment at the start of the first actor's turn in the new round, not
    at the start of the last actor's turn in the previous round (which is the current case).
        -poss. trigger a loop to start when the turnOrderReset value is reset to 0, and have the loop end at the start
        of the next round which causes the round number to increment then.

Add in literally all of the abilities for characters.
    -figure out all of the abilities for characters.

Remove a line of pixels from the top and left side of the tile highlight. Replace with transparent pixels (so it fits
    properly within the tile outlines).

Add in a "Spawn far too many kobolds!" button. V. IMPORTANT

Ask Andrew why using this code:
function checkCollisionUp() {
    for (var i = 0; i < actLen; i ++) {
        // stores currently active actor
        var active = actorArray[i];
        if (actorArray[i] === currentActive) {
            // checks if the tile the actor just moved onto was marked as a 5 in the map array
            if (mapGrid[active.xPos][active.yPos] === 5) {
                //console.log("Move to tile " + actorArray[i].xPos + "," + actorArray[i].yPos);
                active.xPos++;
                movesRemaining++;
                //console.log("Returned to tile " + actorArray[i].xPos + "," + actorArray[i].yPos)
            }
        }
        if (active.xPos === actPosX[i] && active.yPos === actPosY[i]) {
            active.xPos++;
            movesRemaining++;
        }
    }
}
in the checkCollision functions was causing all of the other actors to move up one X position (i.e. down one tile on the
screen), but only on the first movement of the currently active sprite, but not on the subsequent movements.
Note: Putting the:
var active = actorArray[i];
into the first if statement fixes this.